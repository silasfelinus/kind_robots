Help me develop my component BotPrompt using vue 3.2 composition api. My project is 


KindRobots is a community service to provide helpful tools using NLP processors like ChatGPT.
Vue 3.2, Nuxt 3, composition api, mysql, prisma, pinia.

TODO:
*Chatbots send and receive messages
-  separate our concerns to reduce BotPrompt complexity
 - messages are added to channel array and properly packages for chained messages.
 - message streaming
 - channel store handles sending and receiving channels
 - amibot slogan chooser
 - share with facebook
 - share with twitter
 - mobile design
 - modular design
 - fundraiser page & promotions
 - modular bots handle different bottypes
 - image bots send and receive packets.
 - amibot art chooser
 - under construction setup for bots and pages incompleted
[begin sending out resumes and links]
host on outside service
prompts are stores in prisma database
prompt history manager
chat histories are viewable on individual pages
chat histories are editable
gallery page
gamescreen page
user logins
sponsors Cards/Page formatting
Social page
Discord
Facbook
Instagram
giftshop

[files]
/stores/bot.ts
/types/bot.ts (should we combine this with store? It's an awkward element to juggle and it's existence attacks our conception of the bot store as the single source of information for bots)

botcard.vue - early mockup of a Bot, does not have promptbot logic
botprompt.vue - reads ActiveBot from store and populates BotCard

api routes/
/api/channels/[id]/messages.get.ts
channels/[channel].get.ts
/api/channels/index.get.ts
/api/channels/post.ts

/api/messages/[id].get.ts
/api/messages/post.ts

/api/bots/get.ts
/api/bots/[id].get.ts

/api/botcafe/chat.ts // our bridge to openai api

BotPrompt functions:
fetchPrompt
FetchMessage
PostPrompt
PostMessage

export interface Bot {
  id: number
  name: string
  BotType: string
  description: string
  avatarImage?: string
  model?: string
  post?: string
  temperature?: number
  maxTokens?: number
  prompt: string
  image?: string
  mask?: string
  style?: string
  n?: number
  createdAt?: Date
  updatedAt?: Date
  userIntro?: string
  size?: string
}

BotTypes our upper level method to learn if we are chatting, expecting a completion, or working with images. It's current use in code is to decide whether we need to construct a message array by checking for "chatbot"

current bottypes  { 'chatbot', 'artbot'}


model Message {
  id             Int           @id @default(autoincrement())
  content        String        @default("")
  role           String
  channel        String
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  channelId Int?
  Channel   Channel? @relation(fields: [channelId], references: [id])
}

model Channel {
  id          Int       @id @default(autoincrement())
  messages    Message[]
  channel     String
  dateCreated DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}


We are developing BotPrompt. We only make a channel if the bottype is chatbot, but we should always PostMessage if user submits something.


An example exchange:
User selects ActiveBot Amibot. Amibot has these fields:
  {
    id: 0,
    name: 'AMIb0t',
    BotType: 'chatbot',
    description: 'Raising awareness to purchase mosquito nets for children in africa',
    avatarImage: '/images/wonderchest/wonderchest304_(23).webp',
    model: 'gpt-3.5-turbo',
    post: 'https://api.openai.com/v1/completions',
    temperature: 1.0,
    maxTokens: 500,
    n: 1,
    prompt:
      'Please respond as AMIB0t, The Anti-Malaria Intelligence, a hyperkinetic Digital Hive-mind created to fight malaria through social outreach and humor'
  },

  PromptBot imports useBotsStore and checks for ActiveBot. (EXTRA: LoadDefaultBot If there is no activebot, it should display a warning and load AmiBot instead.)

BotPrompt should display the ActiveBot in a pleasant and friendly design that utilizes tailwind and daisyui. Color variables are bg-primary, br-secondary, and bg-accent (with minimal use of black, grey, white). Feel free to remix this and use them as bases for gradients and shades, but do not use other colors. Mobile friendly design, horizontal layout fit to screen on desktop. Video Game aesthetics.

BotCard should display
Name
Description
BotType
AvatarImage (large Image, think like a flag or a character sheet to an rpg)
Left of Avatar and title info should be the description in large friendly letters.
Do not show model or post, those are sent in the packet
Temperature should be reported on the front end as a pleasing slider going between Most Creative (0.0) to Most Consistent (1.0). Step 0.1
maxTokens, if it exists, should be displayed as a minimally sized  drop-down selector stepping between 100-8000, step 100 until 1000, then doubling each time.
n is number of iterations. It should be reported as such on front-end. It is also a dropdown, 1-8.
Prompt exists regardless of bot, and ActiveBot.prompt should be loaded into the prompt textbox for editing. The UserPrompt should be tied to a channel based on botname

[comments on prompts and channels]
front-end channels link message history and bots, but are planned to be extendable to other types, like giving each bot their own livechatroom linked to their name. By having a channnel tied to the Bot.name, it will allow us to use the same system for custom chatrooms based on users, galleries, and even individual pictures. We want channels to help us track the user changing prompts, so if they change a prompt, change bot (which changes prompt), then change back, their prompt has persisted.

[messages and channels]
check for existing channel,
activeChannel=PostChannel(channel = ActiveBot.name)

is it a chatbot? If so, make a messages array from userPrompt

add prompt to messages database:
{content = userPrompt
  role  = 'User'
  channel ActiveBot.name
  ChannelID = activeChannel.id
}
