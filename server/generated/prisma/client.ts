
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.
 *
 * ðŸŸ¢ You can import this file directly.
 */

import * as process from 'node:process'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
globalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))

import * as runtime from "@prisma/client/runtime/client"
import * as $Enums from "./enums"
import * as $Class from "./internal/class"
import * as Prisma from "./internal/prismaNamespace"

export * as $Enums from './enums'
export * from "./enums"
/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Arts
 * const arts = await prisma.art.findMany()
 * ```
 * 
 * Read more in our [docs](https://pris.ly/d/client).
 */
export const PrismaClient = $Class.getPrismaClientClass()
export type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions["omit"] = Prisma.PrismaClientOptions["omit"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>
export { Prisma }

/**
 * Model Art
 * Art holds the overarching data for possibly multiple artImage objects. I've tinkered with having a unified Art object to avoid obfuscation, this is the most complex model we have between Art, ArtCollection, and ArtImage, but the hope was that separating would allow easy handling of the entire Art model array, while selectively calling for the ArtImage data when needed.
 */
export type Art = Prisma.ArtModel
/**
 * Model ArtImage
 * ArtImage is meant to be grabbed as needed, to avoid data bloat. The primary element is imageData
 */
export type ArtImage = Prisma.ArtImageModel
/**
 * Model ArtCollection
 * 
 */
export type ArtCollection = Prisma.ArtCollectionModel
/**
 * Model Bot
 * 
 */
export type Bot = Prisma.BotModel
/**
 * Model Character
 * 
 */
export type Character = Prisma.CharacterModel
/**
 * Model Chat
 * a chat can be between users, user to Bot or Character, on to a Forum or Channel (aka chatroom)
 * originId should always be shared in subsequent messages so we can track the thread via originID and createdAt
 * splitting the chat into a new thread creates a fresh originId
 */
export type Chat = Prisma.ChatModel
/**
 * Model Component
 * Components track all the components we use making kindrobots. it's primary uses are as a museum of developmental attemps, while allowing reactions to allow sifting concepts and allowing the best to rise to attention.
 */
export type Component = Prisma.ComponentModel
/**
 * Model Dominion
 * this is a novelty dominion card generator, allowing the creation and sharing of custom cards for the excellent Dominion card game system.
 */
export type Dominion = Prisma.DominionModel
/**
 * Model Gallery
 * our mostly-obsolete system for collecting images. It assumed data was kept as physical files on disk, and is still used to access the original seed images, which are only partly digitized and used primarily for our Memory Match game, which is the clearest proof of concept that all of this can be used for a functional purpose.
 */
export type Gallery = Prisma.GalleryModel
/**
 * Model Log
 * our woefully underutilized log function, but it's there.
 */
export type Log = Prisma.LogModel
/**
 * Model Milestone
 * website achievements! This holds the milestones that can be achieved (in the flavor text we refer to them as "jellybeans"). They are not user editable and set by myself. only about 1/3 are currently utilized, and one of my biggest todos before public release.
 */
export type Milestone = Prisma.MilestoneModel
/**
 * Model MilestoneRecord
 * the records of milestones earned. They record the date, username, id, etc. Users are given the option to clear their milestones so they can hunt fresh. I use this extensively in debugging.
 */
export type MilestoneRecord = Prisma.MilestoneRecordModel
/**
 * Model Pitch
 * A Pitch is a big picture idea that is meant to be fuel for a project that can become art assets, text assets, and physical swag. A Pitch can contain a collection of Prompts, which is an implementation of the Pitch. for example, a Pitch of "wild colors" could contain a series of prompts like "lavender armadillo;  green curd; rainbow sunburn". it can be represented by an artImage for it's overall vibe, but also collect Art objects if they are inspired by the Pitch 
 */
export type Pitch = Prisma.PitchModel
/**
 * Model Prompt
 * this is an art or text prompt to an ai to generate new media
 */
export type Prompt = Prisma.PromptModel
/**
 * Model Reaction
 * a reaction is created by a user interacting with another object represented in this database. It should be inclusive.
 */
export type Reaction = Prisma.ReactionModel
/**
 * Model Resource
 * This should also be used if a user wants to add a custom art or text generator beyond those servives offered by kind robots. We are intended to be a philanthropic service, so if users use our frameworks without taxing our servers, that is ideal. That said, we aim to be agnostic while encouraging ethical use. In the next year I hope to offer services hosted through solar power locally, and that may change how we encourage services. At the moment, the environmental impact of AI is a valid criticism and I hope the benefits end up being a net gain for the world, as our particular endeavor hopes to be.
 */
export type Resource = Prisma.ResourceModel
/**
 * Model Reward
 * Reward has morphed in intent, it used to be used specifically as a reward for completing a Scenario, and still can be. But in general it is an Item model, and users have the ability to create their own rewards as one shot storytelling prompts in Scenarios. They are designed in the format of the game Equisite Corpse, where storytellers take turns creating a story with a cliffhanger, then expecting the next storyteller to respond. With Scenarios, it's usually user and AI (or multiple users), and the idea was that a reward would be a crazy twist to the narrative, exemplified by our first Reward: The Button that Blows up the World.
 */
export type Reward = Prisma.RewardModel
/**
 * Model Scenario
 * Scenarios are meant to be chatroom settings or storytelling scenarios that incorporate other elements like Character, prompt, Art, etc. A user is given options to continue the scenario with a skill check, inventory item, Reward, or custom prompt. The idea is to generate a story through the back and forth exchange.
 */
export type Scenario = Prisma.ScenarioModel
/**
 * Model SmartIcon
 * Smart Icons are used internally to generate the user's icon array. They can create custom icons that are links to pages or commands
 */
export type SmartIcon = Prisma.SmartIconModel
/**
 * Model Tag
 * tags are used to sort Pitches, Reactions, Dominions, or Components. They can be expanded to other Models but haven't. ArtImage is used to represent the Tag on the front end.
 */
export type Tag = Prisma.TagModel
/**
 * Model Theme
 * 
 */
export type Theme = Prisma.ThemeModel
/**
 * Model User
 * our user model. default test user is userId=10. 
 */
export type User = Prisma.UserModel
/**
 * Model ReactionToTag
 * 
 */
export type ReactionToTag = Prisma.ReactionToTagModel
/**
 * Model ArtToProduct
 * 
 */
export type ArtToProduct = Prisma.ArtToProductModel
/**
 * Model ArtToTag
 * 
 */
export type ArtToTag = Prisma.ArtToTagModel
/**
 * Model MilestoneToUser
 * 
 */
export type MilestoneToUser = Prisma.MilestoneToUserModel
/**
 * Model RewardToUser
 * 
 */
export type RewardToUser = Prisma.RewardToUserModel
