generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum ModelType {
  BOT
  GALLERY
  MEDIA
  MESSAGE
  PROJECT
  PROMPT
  QUEST
  REACTION
  RESOURCE
  USER
  MODEL
  DREAM
  STATUS
  ERROR
  CONTENT
  GAME
}

// example model for style guide
model Model {
  id        Int       @id @unique @default(autoincrement())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  modelType ModelType
  label     String
  content   String
  userId    Int?
  User      User?     @relation(fields: [userId], references: [id])
}

// these are modeler and api resource types
// to process media data
enum ResourceType {
  CHECKPOINT
  EMBEDDING
  LORA
  LYCORIS
  HYPERNETWORK
  CONTROLNET
  URL
  API
}

enum Role {
  SYSTEM
  USER
  ASSISTANT
  ADMIN
  GUEST
  BOT
  DESIGNER
}

// ***BOT
// our modular promptbots
// the meat-and-potatoes of our tech interactibles
model Bot {
  id                Int            @id @unique @default(autoincrement())
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  BotType           BotType        @default(CHATBOT)
  name              String         @unique
  isPublic          Boolean        @default(true)
  underConstruction Boolean        @default(false)
  canDelete         Boolean        @default(false)
  subtitle          String         @default("Kind Robot")
  description       String         @default("I'm a kind robot")
  avatarImage       String         @default("/images/wonderchest/wonderchest304_(23).webp")
  botIntro          String         @default("You're a Kind Robot")
  userIntro         String         @default("Let's make a difference. Here's my idea:")
  prompt            String         @default("Arm butterflies with mini-flamethrowers to kick mosquitos butts")
  trainingPath      String?
  theme             String?
  personality       String         @default("helpful, inquisitive, considerate")
  modules           String?
  User              User?          @relation(fields: [userId], references: [id])
  userId            Int?
  Media             Media[]
  TrainingData      TrainingData[]
}

enum BotType {
  PROMPTBOT
  CHATBOT
  ARTBOT
}

// media collections
model Gallery {
  id             Int      @id @unique @default(autoincrement())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  name           String   @unique
  content        String
  Media          Media[]
  description    String?
  mediaId        String?
  url            String?
  isNSFW         Boolean  @default(false)
  custodian      String?
  User           User?    @relation(fields: [userId], references: [id])
  userId         Int?
  highlightImage String?
  imagePaths     String?  @db.Text
}

// User Incentivization and interaction element
model Game {
  id         Int      @id @unique @default(autoincrement())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  content    String
  category   String   @default("Blue Sky Tasks")
  isFinished Boolean  @default(false)
  User       User     @relation(fields: [userId], references: [id])
  userId     Int
  reward     String   @default("A Magic Reward")
  icon       String?
  points     Int      @default(10)
  isPrivate  Boolean  @default(false)
}

// Any bob-text media deemed important enough to store in the database
model Media {
  id           Int      @id @unique @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  path         String   @default("/")
  isNSFW       Boolean  @default(false)
  isFavorite   Boolean  @default(false)
  isFlagged    Boolean  @default(false)
  tags         String   @default("AI, Cafe Purr")
  designer     String?
  exifDataId   Int?
  User         User?    @relation(fields: [userId], references: [id])
  userId       Int?
  Gallery      Gallery? @relation(fields: [galleryId], references: [id])
  galleryId    Int?
  Bot          Bot?     @relation(fields: [botId], references: [id])
  botId        Int?
  description  String?
  negative     String?
  steps        Int?
  seed         Int?
  sampler      String?
  cfg          String?
  size         String?
  modelHash    String?
  modelName    String?
  template     String?
  negTemplate  String?
  clipData     String?
  deepboroData String?
}

// Public and private salons hosted by users
// The name changes frequently: pitch, concept, vision, Vibe, Collection, Group, Page...
model Project {
  id                 Int      @id @unique @default(autoincrement())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  name               String
  title              String
  category           String
  content            String   @default("Here's the idea...")
  allowComments      Boolean  @default(false)
  description        String   @default("")
  isPublic           Boolean  @default(true)
  hasAdmission       Boolean  @default(false)
  paywallDestination String?
  Host               User     @relation(fields: [userId], references: [id])
  hostId             Int
  usdFee             Float
  portalUrl          String?
  pitchUrl           String?
  userId             Int
}

//raw text data for API processing
// prompt is colloquial for ai-art modeling text data
model Prompt {
  id         Int        @id @unique @default(autoincrement())
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  StringType StringType
  label      String
  content    String
  User       User       @relation(fields: [userId], references: [id])
  userId     Int
}

// Reaction / review system
// Bot reactions can be recovered with Reaction.content
model Reaction {
  id          Int       @id @unique @default(autoincrement())
  User        User      @relation(fields: [userId], references: [id])
  userId      Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  reviewTitle String?
  modelType   ModelType
  modelId     Int
  content     String?
  rating      Int?
}

// Online resources such as checkpoints, embeddings
// lora, hypernetworks, and urls worth preserving
model Resource {
  id           Int          @id @unique @default(autoincrement())
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  User         User?        @relation(fields: [userId], references: [id])
  userId       Int?
  name         String       @unique
  isNSFW       Boolean      @default(false)
  customLabel  String?
  MediaPath    String?
  customUrl    String?
  civitaiUrl   String?
  huggingUrl   String?
  localPath    String?
  description  String?
  resourceType ResourceType @default(CHECKPOINT)
}

// Reward model
model Reward {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  icon       String
  text       String   @unique
  power      String
  collection String   @default("genesis")
  User       User[]
  Todo       Todo[]
  rarity     Int      @default(50)
}

enum StringType {
  TAG //single unit tag phrase 
  PROMPT //combined nlp prompt message
  WILDCARD //list for randomized generations
  RESPONSE //message response nlp to human
  MEDIA_URL // Media url
  URL // generic web url
  CODE //validated codewall
  ERROR // An Error message125m.
}

// Todo model
model Todo {
  id        Int      @id @default(autoincrement())
  task      String
  category  String
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  userId    Int
  User      User     @relation(fields: [userId], references: [id])
  rewardId  Int?
  Reward    Reward?  @relation(fields: [rewardId], references: [id])
}

model TrainingData {
  id        Int            @id @unique @default(autoincrement())
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  label     String
  Bots      Bot[]
  training  TrainingLine[] // <-- many-to-many relationship
}

model TrainingLine {
  id           Int            @id @unique @default(autoincrement())
  role         String
  content      String // The content of that role in a particular turn
  TrainingData TrainingData[] // < traininglines should be reusable in multiple trainindData structures
}

// UserAuth model for authentication-related fields
model UserAuth {
  id       Int     @id @unique @default(autoincrement())
  salt     String?
  email    String? @unique
  username String  @unique
  password String?
  // User relation
  userId   Int?    @unique
  User     User?   @relation(fields: [userId], references: [id])
}

model User {
  id            Int        @id @unique @default(autoincrement())
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  Role          Role       @default(USER)
  username      String     @unique
  email         String?    @unique
  emailVerified DateTime?
  questPoints   Int        @default(0)
  name          String?
  bio           String?    @default("I was born and then things happened and now I'm here.")
  birthday      DateTime?
  address1      String?
  address2      String?
  city          String?
  state         String?
  country       String? // Consider using an enum if the list of countries is fixed
  timezone      String?
  phone         String?
  languages     String? // Consider using String[] if using PostgreSQL
  avatarImage   String?    @default("/images/botcafe.webp")
  // Social Media
  instagramUrl  String?
  twitterUrl    String?
  facebookUrl   String?
  discordUrl    String?
  kindrobotsUrl String?
  // Relations
  accounts      Account[]
  sessions      Session[]
  Bots          Bot[]
  Galleries     Gallery[]
  Media         Media[]
  Prompts       Prompt[]
  Game          Game[]
  Reactions     Reaction[]
  Resources     Resource[]
  Projects      Project[]
  Model         Model[]
  Todo          Todo[]
  Rewards       Reward[]
  UserAuth      UserAuth?
}

model Account {
  id                    Int     @id @unique @default(autoincrement())
  userId                Int
  type                  String
  provider              String
  providerAccountId     String
  refreshToken          String?
  refreshTokenExpiresIn Int?
  accessToken           String?
  expiresAt             Int?
  tokenType             String?
  scope                 String?
  idToken               String?
  sessionState          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           Int      @id @unique @default(autoincrement())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
